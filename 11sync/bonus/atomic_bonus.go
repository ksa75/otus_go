package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

// в этом примере мы с помощью атомик-операций в 1000 горутин увеличиваем значение
// переменной v на 1. В конце работы программы переменная v ожидаемо содержит 1000
// Вторым атомик-действием мы прибавляем к переменной sum текущее значение v
// можно предположить, что мы таким образом в переменной sum получим
// сумму чисел от 1 до 1000. Ведь в каждой следующей горутине после
// выполнения 24 строки v уже будет на 1 больше.

// сумма чисел от 1 до 1000 должна бытьравна 500500
// (это легко проверить через арифметическую прогрессию,
// написав простую программку или посчитав в excel)

// но результат выполнения программы порой оказывается отличным от 500500
// да еще и отличающийся от запуска к запуску.
// Этот пример иллюстрирует, что группа последовательных атомик-операций
// уже атомарной не является!
// между выполнением атомарных операций в одной горутине может пройти время,
// за которое другие горутины успеют поменять использующиеся значения.

// если нам необходима атомарность группы операций - то уже необходимо
// использовать мьютекс
func main() {
	wg := sync.WaitGroup{}

	var v int64
	var sum int64
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			atomic.AddInt64(&v, 1)
			atomic.AddInt64(&sum, v)
			wg.Done()
		}()
	}

	wg.Wait()
	fmt.Println(v)
	fmt.Println(sum)
}
